<!-- The content below will be included at the end of the <head> element. -->
<!-- Add Tesseract.js and its worker -->
<!-- The content below will be included at the end of the <head> element. -->
<!-- Add Tesseract.js and its worker -->
<script src="https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js"></script>
<script>
  // Initialize tesseract worker - Updated for v4+ API
  window.Tesseract = Tesseract; // Remove .create() call
</script>

<script type="text/javascript">
// Constants
const DELAY = 200;
const COPY_FEEDBACK_DELAY = 2000;
const OCR_CACHE_PREFIX = 'ocr_cache_';
const CLEAR_CACHE_BUTTON_ENABLED = false;

// Utility functions
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Add this new function
function clearOCRCache() {
  const keys = Object.keys(localStorage);
  let clearedCount = 0;
  
  keys.forEach(key => {
    if (key.startsWith(OCR_CACHE_PREFIX)) {
      localStorage.removeItem(key);
      clearedCount++;
    }
  });
  
  alert(`Cleared ${clearedCount} OCR cache entries`);
}

// Image handling class
class ImageHandler {
  constructor() {
    this.figureCount = 0;
    this.isZoomed = false;
    this.processingOCR = new Set(); // Track images being processed
  }

  async copyImageToClipboard(img, copyButton) {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      const blob = await new Promise(resolve => canvas.toBlob(resolve));
      await navigator.clipboard.write([
        new ClipboardItem({ [blob.type]: blob })
      ]);
      
      this.showCopyFeedback(copyButton);
    } catch (err) {
      console.error('Failed to copy image:', err);
      this.showCopyFeedback(copyButton, true);
    }
  }

  handleImageZoom(img, e) {
    const rect = img.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 100;
    const y = ((e.clientY - rect.top) / rect.height) * 100;
    
    if (!this.isZoomed) {
      this.zoomIn(img, x, y);
    } else {
      this.zoomOut(img);
    }
  }

  zoomIn(img, x, y) {
    img.style.transform = 'scale(2)';
    img.style.transformOrigin = `${x}% ${y}%`;
    img.style.cursor = 'zoom-out';
    img.style.position = 'relative';
    img.style.zIndex = '999';
    this.isZoomed = true;
  }

  zoomOut(img) {
    img.style.transform = 'scale(1)';
    img.style.cursor = 'zoom-in';
    img.style.position = 'static';
    img.style.zIndex = 'auto';
    this.isZoomed = false;
  }

  showCopyFeedback(button, isError = false) {
    const originalText = button.textContent;
    button.textContent = isError ? 'Error!' : 'Copied!';
    setTimeout(() => {
      button.textContent = originalText;
    }, COPY_FEEDBACK_DELAY);
  }

  async processImages() {
    await sleep(DELAY);
    this.figureCount = 0;
    
    document.querySelectorAll('img').forEach(img => {
      if (img.parentNode.tagName === 'FIGURE') return;

      this.figureCount++;
      this.wrapImageInFigure(img);
    });
  }

  async getImageHash(img) {
    // Create a canvas to draw the image
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    
    // Draw image to canvas
    ctx.drawImage(img, 0, 0);
    
    // Get image data (RGBA values for each pixel)
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    
    // Simple but fast hashing function
    let hash = 0;
    for (let i = 0; i < imageData.length; i++) {
      const byte = imageData[i];
      hash = ((hash << 5) - hash) + byte;
      hash = hash & hash; // Convert to 32-bit integer
    }
    
    // Convert to base64-safe string
    return btoa(hash.toString()).replace(/[/+=]/g, '_');
  }

  async processImageOCR(img, ocrButton) {
    const hash = await this.getImageHash(img);
    const cacheKey = OCR_CACHE_PREFIX + hash;
    
    // Check cache first
    const cachedText = localStorage.getItem(cacheKey);
    if (cachedText) {
      ocrButton.textContent = 'OCR';
      ocrButton.disabled = false;
      return cachedText;
    }

    // Mark as processing
    this.processingOCR.add(hash);
    ocrButton.disabled = true;
    ocrButton.textContent = '0%';

    try {
      const { data: { text } } = await Tesseract.recognize(
        img.src,
        'eng',
        {
          logger: m => {
            if (m.status === 'recognizing text') {
              ocrButton.textContent = `${Math.round(m.progress * 100)}%`;
            }
          }
        }
      );

      // Cache the result
      localStorage.setItem(cacheKey, text);
      
      ocrButton.textContent = 'OCR';
      ocrButton.disabled = false;
      return text;
    } catch (error) {
      console.error('OCR failed:', error);
      ocrButton.textContent = 'OCR Error';
      document.write(error);
      return null;
    } finally {
      this.processingOCR.delete(hash);
    }
  }

  showTextModal(text) {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'ocr-modal';
    
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.className = 'ocr-modal-content';
    
    // Create close button
    const closeButton = document.createElement('span');
    closeButton.className = 'ocr-modal-close';
    closeButton.innerHTML = '&times;';
    closeButton.onclick = () => modal.remove();
    
    // Create text content as textarea instead of pre
    const textContent = document.createElement('textarea');
    textContent.className = 'ocr-modal-textarea';
    textContent.value = text;
    textContent.readOnly = true;
    
    // Create copy button
    const copyButton = document.createElement('button');
    copyButton.textContent = 'Copy Text';
    copyButton.className = 'ocr-modal-copy';
    copyButton.onclick = async () => {
      await navigator.clipboard.writeText(text);
      this.showCopyFeedback(copyButton);
    };
    
    // Assemble modal
    modalContent.appendChild(closeButton);
    modalContent.appendChild(textContent);
    modalContent.appendChild(copyButton);
    modal.appendChild(modalContent);
    
    // Add click outside to close
    modal.onclick = (e) => {
      if (e.target === modal) modal.remove();
    };
    
    document.body.appendChild(modal);
    
    // Auto-select text and focus the textarea when modal opens
    textContent.select();
    textContent.focus();
    
    // Add event listener to prevent Ctrl+A from selecting outside the textarea
    textContent.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'a') {
        e.stopPropagation();
      }
    });
  }

  wrapImageInFigure(img) {
    const figure = document.createElement('figure');
    figure.style.textAlign = 'center';

    const caption = document.createElement('figcaption');
    caption.textContent = `Image ${this.figureCount}: ${img.alt}`;

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'button-container';

    // Only create copy button if the Clipboard API is available
    if (navigator.clipboard && navigator.clipboard.write) {
      const copyButton = document.createElement('button');
      copyButton.className = 'img-copy-button';
      copyButton.textContent = 'Copy';
      copyButton.addEventListener('click', () => this.copyImageToClipboard(img, copyButton));
      buttonContainer.appendChild(copyButton);
    }

    const ocrButton = document.createElement('button');
    ocrButton.className = 'img-copy-button';
    ocrButton.textContent = 'OCR';
    ocrButton.addEventListener('click', async () => {
      const text = await this.processImageOCR(img, ocrButton);
      if (text) {
        this.showTextModal(text);
      }
    });

    img.parentNode.insertBefore(figure, img);
    buttonContainer.appendChild(ocrButton);
    figure.appendChild(buttonContainer);
    figure.appendChild(img);
    figure.appendChild(caption);

    const newImg = this.styleImage(img);
    newImg.addEventListener('mousedown', (e) => this.handleImageZoom(newImg, e));

    // Start OCR processing in background
    this.processImageOCR(newImg, ocrButton);
  }

  styleImage(img) {
    const newImg = img.cloneNode(true);
    img.replaceWith(newImg);
    
    newImg.style.display = 'block';
    newImg.style.marginLeft = 'auto';
    newImg.style.marginRight = 'auto';
    newImg.style.border = '1px solid #ddd';
    newImg.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
    newImg.style.borderRadius = '4px';
    newImg.style.cursor = 'zoom-in';
    newImg.style.transition = 'none';

    return newImg;
  }
}

// Code block handling class
class CodeBlockHandler {
  async processCodeBlocks() {
    document.querySelectorAll('pre[data-role="codeBlock"]').forEach(block => {
      if (block.querySelector('.copy-button')) return;
      this.addCopyButton(block);
    });
  }

  addCopyButton(block) {
    const button = document.createElement('button');
    button.className = 'copy-button';
    button.textContent = 'Copy';
    
    button.addEventListener('click', async () => {
      try {
        const code = block.querySelector('code').textContent;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(code);
        } else {
          // Fallback for browsers that don't support clipboard API
          const textarea = document.createElement('textarea');
          textarea.value = code;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
        }
        this.showCopyFeedback(button);
      } catch (err) {
        console.error('Failed to copy:', err);
        this.showCopyFeedback(button, true);
      }
    });

    block.appendChild(button);
  }

  showCopyFeedback(button, isError = false) {
    button.textContent = isError ? 'Error!' : 'Copied!';
    setTimeout(() => {
      button.textContent = 'Copy';
    }, COPY_FEEDBACK_DELAY);
  }
}


// Main initialization
document.addEventListener("DOMContentLoaded", async function () {
  let clearButton;
  if (CLEAR_CACHE_BUTTON_ENABLED) {
    await sleep(DELAY);
    clearButton = document.createElement('button');
    clearButton.textContent = 'Clear OCR Cache';
    clearButton.style.display = 'inline-block';
    clearButton.style.marginLeft = '15px';
    clearButton.style.verticalAlign = 'right';
    clearButton.addEventListener('click', clearOCRCache);
  }
  
  // Find the first h1 element and append the button to it
  const firstH1 = document.querySelector('h1');
  if (firstH1 && clearButton) {  // Check if clearButton exists
    firstH1.style.display = 'flex';
    firstH1.style.alignItems = 'center';
    firstH1.appendChild(clearButton);
  }

  const imageHandler = new ImageHandler();
  const codeBlockHandler = new CodeBlockHandler();

  // Initial processing
  await imageHandler.processImages();
  await codeBlockHandler.processCodeBlocks();

  // Setup observer
  const observer = new MutationObserver(async (mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === 'childList') {
        const hasNewImages = Array.from(mutation.addedNodes).some(node => 
          node.nodeName === 'IMG' || (node.nodeType === 1 && node.querySelector('img'))
        );
        const hasNewCodeBlocks = Array.from(mutation.addedNodes).some(node =>
          node.nodeName === 'PRE' || (node.nodeType === 1 && node.querySelector('pre[data-role="codeBlock"]'))
        );
        
        if (hasNewImages) await imageHandler.processImages();
        if (hasNewCodeBlocks) await codeBlockHandler.processCodeBlocks();
      }
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
});
</script>

<style>
  figure {
    margin: 1em 0;
    position: relative;
  }

  figcaption {
    text-align: center;
    font-style: italic;
    margin-top: 0.5em;
    color: #8c53cf;
  }

  pre[data-role="codeBlock"] {
    position: relative;
  }

  .copy-button {
    position: absolute;
    bottom: 5px;
    right: 5px;
    padding: 4px 8px;
    font-size: 12px;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid #ddd;
    border-radius: 3px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    z-index: 1000;
  }

  /* Show copy button on hover of the code block */
  pre[data-role="codeBlock"]:hover .copy-button {
    opacity: 0.7;
  }

  .copy-button:hover {
    opacity: 1 !important;
  }

  /* Add styles for button container */
  .button-container {
    position: absolute;
    bottom: 5px;
    right: 5px;
    display: flex;
    gap: 5px;
    z-index: 1000;
  }

  /* Update button styles to remove absolute positioning */
  .button-container .img-copy-button {
    position: static;
    opacity: 0;
  }

  /* Show buttons on hover */
  figure:hover .button-container .img-copy-button {
    opacity: 0.7;
  }

  .copy-button:hover,
  .img-copy-button:hover {
    opacity: 1 !important;
  }

  .img-copy-button:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }

  /* Add these new styles */
  button[onclick="clearOCRCache()"] {
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid #ddd;
    border-radius: 3px;
    cursor: pointer;
    font-size: 14px;
    white-space: nowrap;
  }

  button[onclick="clearOCRCache()"]:hover {
    background: rgba(255, 255, 255, 1);
  }

  /* Add modal styles */
  .ocr-modal {
    display: flex;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.4);
    align-items: center;
    justify-content: center;
  }

  .ocr-modal-content {
    background-color: #fefefe;
    padding: 20px;
    border: 1px solid #888;
    border-radius: 5px;
    width: 80%;
    max-width: 800px;
    max-height: 80vh;
    position: relative;
    display: flex;
    flex-direction: column;
  }

  .ocr-modal-close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    position: absolute;
    right: 10px;
    top: 5px;
  }

  .ocr-modal-close:hover,
  .ocr-modal-close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
  }

  .ocr-modal-content textarea.ocr-modal-textarea {
    margin: 20px 0;
    width: 100%;
    min-height: 200px;
    max-height: calc(80vh - 100px);
    padding: 10px;
    background: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 3px;
    color: #333;
    font-family: monospace;
    font-size: 14px;
    resize: vertical;
    box-sizing: border-box;
  }

  /* Remove the pre styles since we're not using them anymore */
  .ocr-modal-content pre {
    display: none;
  }

  .ocr-modal-copy {
    align-self: flex-end;
    padding: 8px 16px;
    background: #f0f0f0;
    border: 1px solid #ddd;
    border-radius: 3px;
    cursor: pointer;
    margin-top: 10px;
  }

  .ocr-modal-copy:hover {
    background: #e0e0e0;
  }
</style>