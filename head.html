<!-- The content below will be included at the end of the <head> element. -->
<!-- Add Tesseract.js and its worker -->
<script src="https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js"></script>
<script>
  // Initialize tesseract worker
  window.Tesseract = Tesseract.create({
    workerPath: 'https://unpkg.com/tesseract.js@v4.1.1/dist/worker.min.js',
    langPath: 'https://tessdata.projectnaptha.com/4.0.0',
    corePath: 'https://unpkg.com/tesseract.js-core@v4.0.4/tesseract-core.wasm.js',
  });
</script>

<script type="text/javascript">
// Constants
const DELAY = 200;
const COPY_FEEDBACK_DELAY = 2000;
const OCR_CACHE_PREFIX = 'ocr_cache_';

// Utility functions
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Image handling class
class ImageHandler {
  constructor() {
    this.figureCount = 0;
    this.isZoomed = false;
    this.processingOCR = new Set(); // Track images being processed
  }

  async copyImageToClipboard(img, copyButton) {
    try {
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      const blob = await new Promise(resolve => canvas.toBlob(resolve));
      await navigator.clipboard.write([
        new ClipboardItem({ [blob.type]: blob })
      ]);
      
      this.showCopyFeedback(copyButton);
    } catch (err) {
      console.error('Failed to copy image:', err);
      this.showCopyFeedback(copyButton, true);
    }
  }

  handleImageZoom(img, e) {
    const rect = img.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 100;
    const y = ((e.clientY - rect.top) / rect.height) * 100;
    
    if (!this.isZoomed) {
      this.zoomIn(img, x, y);
    } else {
      this.zoomOut(img);
    }
  }

  zoomIn(img, x, y) {
    img.style.transform = 'scale(2)';
    img.style.transformOrigin = `${x}% ${y}%`;
    img.style.cursor = 'zoom-out';
    img.style.position = 'relative';
    img.style.zIndex = '999';
    this.isZoomed = true;
  }

  zoomOut(img) {
    img.style.transform = 'scale(1)';
    img.style.cursor = 'zoom-in';
    img.style.position = 'static';
    img.style.zIndex = 'auto';
    this.isZoomed = false;
  }

  showCopyFeedback(button, isError = false) {
    const originalText = button.textContent;
    button.textContent = isError ? 'Error!' : 'Copied!';
    setTimeout(() => {
      button.textContent = originalText;
    }, COPY_FEEDBACK_DELAY);
  }

  async processImages() {
    await sleep(DELAY);
    this.figureCount = 0;
    
    document.querySelectorAll('img').forEach(img => {
      if (img.parentNode.tagName === 'FIGURE') return;

      this.figureCount++;
      this.wrapImageInFigure(img);
    });
  }

  async getImageHash(img) {
    // Simple hash based on src and dimensions
    const key = `${img.src}_${img.naturalWidth}x${img.naturalHeight}`;
    return btoa(key).replace(/[/+=]/g, '_');
  }

  async processImageOCR(img, ocrButton) {
    const hash = await this.getImageHash(img);
    const cacheKey = OCR_CACHE_PREFIX + hash;
    
    // Check cache first
    const cachedText = localStorage.getItem(cacheKey);
    if (cachedText) {
      ocrButton.textContent = 'OCR';
      ocrButton.disabled = false;
      return cachedText;
    }

    // Mark as processing
    this.processingOCR.add(hash);
    ocrButton.disabled = true;
    ocrButton.textContent = '0%';

    try {
      const { data: { text } } = await Tesseract.recognize(
        img.src,
        'eng',
        {
          logger: m => {
            if (m.status === 'recognizing text') {
              ocrButton.textContent = `${Math.round(m.progress * 100)}%`;
            }
          }
        }
      );

      // Cache the result
      localStorage.setItem(cacheKey, text);
      
      ocrButton.textContent = 'OCR';
      ocrButton.disabled = false;
      return text;
    } catch (error) {
      console.error('OCR failed:', error);
      ocrButton.textContent = 'OCR Error';
      document.write(error);
      return null;
    } finally {
      this.processingOCR.delete(hash);
    }
  }

  wrapImageInFigure(img) {
    const figure = document.createElement('figure');
    figure.style.textAlign = 'center';

    const caption = document.createElement('figcaption');
    caption.textContent = `Image ${this.figureCount}: ${img.alt}`;

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'button-container';

    const copyButton = document.createElement('button');
    copyButton.className = 'img-copy-button';
    copyButton.textContent = 'Copy';
    copyButton.addEventListener('click', () => this.copyImageToClipboard(img, copyButton));

    const ocrButton = document.createElement('button');
    ocrButton.className = 'img-copy-button';
    ocrButton.textContent = 'OCR';
    ocrButton.addEventListener('click', async () => {
      const text = await this.processImageOCR(img, ocrButton);
      if (text) {
        await navigator.clipboard.writeText(text);
        this.showCopyFeedback(ocrButton);
      }
    });

    img.parentNode.insertBefore(figure, img);
    buttonContainer.appendChild(copyButton);
    buttonContainer.appendChild(ocrButton);
    figure.appendChild(buttonContainer);
    figure.appendChild(img);
    figure.appendChild(caption);

    const newImg = this.styleImage(img);
    newImg.addEventListener('mousedown', (e) => this.handleImageZoom(newImg, e));

    // Start OCR processing in background
    this.processImageOCR(newImg, ocrButton);
  }

  styleImage(img) {
    const newImg = img.cloneNode(true);
    img.replaceWith(newImg);
    
    newImg.style.display = 'block';
    newImg.style.marginLeft = 'auto';
    newImg.style.marginRight = 'auto';
    newImg.style.border = '1px solid #ddd';
    newImg.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
    newImg.style.borderRadius = '4px';
    newImg.style.cursor = 'zoom-in';
    newImg.style.transition = 'none';

    return newImg;
  }
}

// Code block handling class
class CodeBlockHandler {
  async processCodeBlocks() {
    document.querySelectorAll('pre[data-role="codeBlock"]').forEach(block => {
      if (block.querySelector('.copy-button')) return;
      this.addCopyButton(block);
    });
  }

  addCopyButton(block) {
    const button = document.createElement('button');
    button.className = 'copy-button';
    button.textContent = 'Copy';
    
    button.addEventListener('click', async () => {
      const code = block.querySelector('code').textContent;
      await navigator.clipboard.writeText(code);
      this.showCopyFeedback(button);
    });

    block.appendChild(button);
  }

  showCopyFeedback(button) {
    button.textContent = 'Copied!';
    setTimeout(() => {
      button.textContent = 'Copy';
    }, COPY_FEEDBACK_DELAY);
  }
}

// Main initialization
document.addEventListener("DOMContentLoaded", async function () {
  const imageHandler = new ImageHandler();
  const codeBlockHandler = new CodeBlockHandler();

  // Initial processing
  await imageHandler.processImages();
  await codeBlockHandler.processCodeBlocks();

  // Setup observer
  const observer = new MutationObserver(async (mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === 'childList') {
        const hasNewImages = Array.from(mutation.addedNodes).some(node => 
          node.nodeName === 'IMG' || (node.nodeType === 1 && node.querySelector('img'))
        );
        const hasNewCodeBlocks = Array.from(mutation.addedNodes).some(node =>
          node.nodeName === 'PRE' || (node.nodeType === 1 && node.querySelector('pre[data-role="codeBlock"]'))
        );
        
        if (hasNewImages) await imageHandler.processImages();
        if (hasNewCodeBlocks) await codeBlockHandler.processCodeBlocks();
      }
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
});
</script>

<style>
  figure {
    margin: 1em 0;
    position: relative;
  }

  figcaption {
    text-align: center;
    font-style: italic;
    margin-top: 0.5em;
    color: #8c53cf;
  }

  pre[data-role="codeBlock"] {
    position: relative;
  }

  .copy-button,
  .img-copy-button {
    position: absolute;
    bottom: 5px;
    right: 5px;
    padding: 4px 8px;
    font-size: 12px;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid #ddd;
    border-radius: 3px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    z-index: 1000;
  }

  /* Add styles for button container */
  .button-container {
    position: absolute;
    bottom: 5px;
    right: 5px;
    display: flex;
    gap: 5px;
    z-index: 1000;
  }

  /* Update button styles to remove absolute positioning */
  .button-container .img-copy-button {
    position: static;
    opacity: 0;
  }

  /* Show buttons on hover */
  figure:hover .button-container .img-copy-button {
    opacity: 0.7;
  }

  .copy-button:hover,
  .img-copy-button:hover {
    opacity: 1 !important;
  }

  .img-copy-button:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
</style>